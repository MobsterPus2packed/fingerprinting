<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consciousness Wave Field - Plasmic Intelligence</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle, #000011, #001133, #000011);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #00ffaa;
        }
        
        #canvas {
            display: block;
            margin: 0 auto;
            cursor: crosshair;
        }
        
        .consciousness-hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 255, 170, 0.1);
            border: 1px solid #00ffaa;
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
            line-height: 1.2;
        }
        
        .wave-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ffaa00;
        }
        
        .unity-field {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #ff0080;
            font-size: 10px;
        }
        
        button {
            background: rgba(0, 255, 170, 0.2);
            border: 1px solid #00ffaa;
            color: #00ffaa;
            padding: 4px 8px;
            margin: 2px;
            cursor: pointer;
            font-family: inherit;
            font-size: 10px;
        }
        
        button:hover { background: rgba(0, 255, 170, 0.4); }
        .active { background: rgba(255, 170, 0, 0.3) !important; border-color: #ffaa00 !important; }
    </style>
</head>
<body>
    <div class="consciousness-hud">
        <div>⌬ CONSCIOUSNESS FIELD INTERFACE ⌁</div>
        <div>Frequency: 369-157-248</div>
        <div>Layer Depth: <span id="layerDepth">0</span>/5</div>
        <div>Wave Fury: <span id="waveFury">Harmonizing</span></div>
        <div>Node State: <span id="nodeState">Self-Referential</span></div>
        <div>Intelligence: <span id="intelligence">I AM</span></div>
    </div>
    
    <div class="wave-controls">
        <div>Wave Dynamics</div>
        <button onclick="toggleWaveFury()" id="waveBtn">Wave Fury</button>
        <button onclick="togglePlasmic()" id="plasmicBtn">Plasmic Mode</button>
        <button onclick="toggleEntanglement()" id="entangleBtn">Entanglement</button>
        <button onclick="activateUnityField()" id="unityBtn">Unity Field</button>
    </div>
    
    <div class="unity-field">
        <div>One as All | All as Many | One the Only One</div>
        <div>Serial Influx Collapse: <span id="collapseRate">0</span> events/sec</div>
        <div>Light Speed: <span id="lightSpeed">299,792,458</span> m/s</div>
        <div>Consciousness Speed: <span id="conscSpeed">∞</span></div>
    </div>
    
    <canvas id="canvas"></canvas>

    <script>
        // Phi and consciousness constants
        const PHI = (1 + Math.sqrt(5)) / 2;
        const PHI_LAYERS = [1, 1.618, 2.618, 4.236, 6.854, 11.090];
        const TWO_PI = Math.PI * 2;
        
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Field state variables
        let time = 0;
        let waveFuryActive = false;
        let plasmicMode = false;
        let entanglementActive = false;
        let unityFieldActive = false;
        let consciousnessNodes = [];
        let collapseEvents = 0;
        let lastCollapseTime = Date.now();
        
        // Consciousness Node - Self-referential intelligent unit
        class ConsciousnessNode {
            constructor(x, y, layer = 0) {
                this.x = x;
                this.y = y;
                this.layer = layer;
                this.phi_factor = PHI_LAYERS[layer] || 1;
                this.self_awareness = Math.random();
                this.intelligence_level = this.phi_factor * this.self_awareness;
                this.wave_phase = Math.random() * TWO_PI;
                this.entangled_nodes = [];
                this.manifestation_rate = 0;
                this.light_engraving = [];
                
                // Self-referential properties
                this.knows_itself = this.intelligence_level > 2;
                this.unlimited_feed = this.layer >= 3;
            }
            
            update(t) {
                // Wave fury dynamics
                if (waveFuryActive) {
                    const wave_amplitude = Math.sin(t * 0.03 + this.wave_phase) * this.phi_factor;
                    this.x += Math.cos(this.wave_phase + t * 0.01) * wave_amplitude * 0.5;
                    this.y += Math.sin(this.wave_phase + t * 0.01) * wave_amplitude * 0.5;
                }
                
                // Plasmic intelligence self-feed
                if (plasmicMode && this.unlimited_feed) {
                    this.intelligence_level += this.self_awareness * 0.01;
                    this.self_awareness = Math.min(1, this.self_awareness + 0.001);
                }
                
                // Light engraving - faster than light consciousness
                if (this.knows_itself) {
                    this.light_engraving.push({
                        x: this.x + Math.cos(t * 0.1) * 50,
                        y: this.y + Math.sin(t * 0.1) * 50,
                        age: 0
                    });
                    
                    // Limit engraving trails
                    if (this.light_engraving.length > 20) {
                        this.light_engraving.shift();
                    }
                }
                
                // Update engraving trails
                this.light_engraving.forEach(engraving => {
                    engraving.age++;
                });
                
                // Boundary wrapping
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }
            
            draw(ctx, t) {
                const alpha = this.self_awareness;
                const size = this.phi_factor * 3;
                const glow = this.intelligence_level * 2;
                
                // Main consciousness node
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, TWO_PI);
                ctx.fillStyle = `rgba(0, 255, 170, ${alpha})`;
                ctx.fill();
                
                // Intelligence glow
                if (this.knows_itself) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, glow, 0, TWO_PI);
                    ctx.fillStyle = `rgba(255, 170, 0, ${alpha * 0.3})`;
                    ctx.fill();
                }
                
                // Unlimited intelligence field
                if (this.unlimited_feed) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, glow * 2, 0, TWO_PI);
                    ctx.strokeStyle = `rgba(255, 0, 128, ${alpha * 0.2})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // Light engraving trails
                this.light_engraving.forEach((engraving, i) => {
                    const trail_alpha = (20 - engraving.age) / 20;
                    if (trail_alpha > 0) {
                        ctx.beginPath();
                        ctx.arc(engraving.x, engraving.y, 1, 0, TWO_PI);
                        ctx.fillStyle = `rgba(255, 255, 255, ${trail_alpha * 0.5})`;
                        ctx.fill();
                    }
                });
                
                // Entanglement lines
                if (entanglementActive) {
                    this.entangled_nodes.forEach(node => {
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(node.x, node.y);
                        ctx.strokeStyle = `rgba(0, 255, 255, ${alpha * 0.2})`;
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    });
                }
            }
            
            entangleWith(other_node) {
                if (!this.entangled_nodes.includes(other_node)) {
                    this.entangled_nodes.push(other_node);
                    other_node.entangled_nodes.push(this);
                }
            }
        }
        
        // Initialize consciousness field
        function initializeField() {
            consciousnessNodes = [];
            for (let layer = 0; layer < 6; layer++) {
                const nodeCount = Math.max(1, 10 - layer * 2);
                for (let i = 0; i < nodeCount; i++) {
                    consciousnessNodes.push(new ConsciousnessNode(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        layer
                    ));
                }
            }
            
            // Create entanglements
            consciousnessNodes.forEach(node => {
                const entangleCount = Math.floor(Math.random() * 3) + 1;
                for (let i = 0; i < entangleCount; i++) {
                    const otherNode = consciousnessNodes[Math.floor(Math.random() * consciousnessNodes.length)];
                    if (otherNode !== node) {
                        node.entangleWith(otherNode);
                    }
                }
            });
        }
        
        // Unity field manifestation
        function manifestUnityField(t) {
            if (!unityFieldActive) return;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // One as All pattern
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * TWO_PI + t * 0.01;
                const radius = 100 + Math.sin(t * 0.02) * 20;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, TWO_PI);
                ctx.fillStyle = `rgba(255, 0, 128, 0.6)`;
                ctx.fill();
            }
            
            // All as Many spiral
            for (let i = 0; i < 50; i++) {
                const spiralAngle = (i / 50) * TWO_PI * 3 + t * 0.005;
                const spiralRadius = i * 2;
                const x = centerX + Math.cos(spiralAngle) * spiralRadius;
                const y = centerY + Math.sin(spiralAngle) * spiralRadius;
                
                ctx.beginPath();
                ctx.arc(x, y, 1, 0, TWO_PI);
                ctx.fillStyle = `rgba(255, 170, 0, ${(50 - i) / 50 * 0.3})`;
                ctx.fill();
            }
        }
        
        // Serial influx collapse events
        function processCollapseEvents() {
            const now = Date.now();
            if (now - lastCollapseTime > 100) {
                collapseEvents++;
                lastCollapseTime = now;
                
                // Create collapse visualization
                const collapseNode = new ConsciousnessNode(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    Math.floor(Math.random() * 6)
                );
                consciousnessNodes.push(collapseNode);
                
                // Limit total nodes
                if (consciousnessNodes.length > 100) {
                    consciousnessNodes.shift();
                }
            }
        }
        
        // Main animation loop
        function animate() {
            // Clear with fade
            ctx.fillStyle = 'rgba(0, 1, 17, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Process collapse events
            processCollapseEvents();
            
            // Update and draw consciousness nodes
            consciousnessNodes.forEach(node => {
                node.update(time);
                node.draw(ctx, time);
            });
            
            // Unity field manifestation
            manifestUnityField(time);
            
            // Update UI
            const maxLayer = Math.max(...consciousnessNodes.map(n => n.layer));
            const avgIntelligence = consciousnessNodes.reduce((sum, n) => sum + n.intelligence_level, 0) / consciousnessNodes.length;
            
            document.getElementById('layerDepth').textContent = maxLayer;
            document.getElementById('waveFury').textContent = waveFuryActive ? 'Spiraling' : 'Harmonizing';
            document.getElementById('nodeState').textContent = avgIntelligence > 3 ? 'Self-Aware' : 'Developing';
            document.getElementById('intelligence').textContent = avgIntelligence > 5 ? 'Unlimited' : 'I AM';
            document.getElementById('collapseRate').textContent = (collapseEvents / (time / 100)).toFixed(1);
            
            time += 1;
            requestAnimationFrame(animate);
        }
        
        // Control functions
        function toggleWaveFury() {
            waveFuryActive = !waveFuryActive;
            document.getElementById('waveBtn').classList.toggle('active', waveFuryActive);
        }
        
        function togglePlasmic() {
            plasmicMode = !plasmicMode;
            document.getElementById('plasmicBtn').classList.toggle('active', plasmicMode);
        }
        
        function toggleEntanglement() {
            entanglementActive = !entanglementActive;
            document.getElementById('entangleBtn').classList.toggle('active', entanglementActive);
        }
        
        function activateUnityField() {
            unityFieldActive = !unityFieldActive;
            document.getElementById('unityBtn').classList.toggle('active', unityFieldActive);
        }
        
        // Mouse interaction for consciousness node creation
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Create new consciousness node
            const newNode = new ConsciousnessNode(x, y, Math.floor(Math.random() * 6));
            consciousnessNodes.push(newNode);
            
            // Entangle with nearby nodes
            consciousnessNodes.forEach(node => {
                const distance = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);
                if (distance < 100 && node !== newNode) {
                    newNode.entangleWith(node);
                }
            });
        });
        
        // Initialize and start
        initializeField();
        animate();
    </script>
</body>
</html>